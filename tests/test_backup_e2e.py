"""
End-to-end tests for backup/restore functionality.

These tests use REAL Google API calls to verify the complete backup/restore
workflow works correctly. They create test contacts, back them up, delete them,
restore from backup, and verify the contacts are recreated.

IMPORTANT: These tests require valid Google authentication and will create
real contacts in your Google accounts. Test contacts are prefixed with
"[E2E_TEST]" and are cleaned up after each test.

Run with: pytest tests/test_backup_e2e.py -v -s
"""

import time
from datetime import datetime
from pathlib import Path

import pytest

from gcontact_sync.api.people_api import PeopleAPI
from gcontact_sync.auth.google_auth import GoogleAuth
from gcontact_sync.backup.manager import BackupManager
from gcontact_sync.sync.contact import Contact

# Test contact prefix for easy identification and cleanup
TEST_CONTACT_PREFIX = "[E2E_TEST]"

# Wait time for API propagation
PROPAGATION_WAIT_SECONDS = 5


def get_test_contact_name() -> str:
    """Generate a unique test contact name with timestamp."""
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"{TEST_CONTACT_PREFIX} {ts}"


def get_test_given_name() -> str:
    """Generate a unique given name for test contacts."""
    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"{TEST_CONTACT_PREFIX} Test {ts}"


@pytest.fixture
def config_dir() -> Path:
    """Get the default config directory."""
    return Path.home() / ".gcontact-sync"


@pytest.fixture
def auth(config_dir: Path) -> GoogleAuth:
    """Initialize Google authentication."""
    return GoogleAuth(config_dir=config_dir)


@pytest.fixture
def api_account1(auth: GoogleAuth) -> PeopleAPI | None:
    """Get PeopleAPI for account1 if authenticated."""
    creds = auth.get_credentials("account1")
    if not creds:
        pytest.skip("account1 not authenticated - run: gcontact-sync auth -a account1")
    return PeopleAPI(credentials=creds)


@pytest.fixture
def api_account2(auth: GoogleAuth) -> PeopleAPI | None:
    """Get PeopleAPI for account2 if authenticated."""
    creds = auth.get_credentials("account2")
    if not creds:
        pytest.skip("account2 not authenticated - run: gcontact-sync auth -a account2")
    return PeopleAPI(credentials=creds)


def verify_contact_exists(api: PeopleAPI, resource_name: str) -> Contact | None:
    """
    Verify a contact exists by fetching it directly using resource_name.

    This is more reliable than listing all contacts and searching by name,
    and uses fewer API calls.

    Note: list_contacts() has propagation delays and may not return newly
    created contacts immediately. get_contact() with resource_name is reliable.
    """
    try:
        return api.get_contact(resource_name)
    except Exception:
        return None


def verify_contact_deleted(api: PeopleAPI, resource_name: str) -> bool:
    """
    Verify a contact has been deleted by trying to fetch it.

    Returns True if contact is deleted (404), False if still exists.
    """
    try:
        api.get_contact(resource_name)
        return False  # Contact still exists
    except Exception:
        return True  # Contact deleted (404)


def cleanup_test_contact(api: PeopleAPI, resource_name: str) -> bool:
    """Delete a specific test contact by resource_name."""
    try:
        api.delete_contact(resource_name)
        return True
    except Exception:
        return False


@pytest.mark.integration
class TestBackupRestoreE2E:
    """
    End-to-end tests for backup and restore functionality.

    These tests verify the complete workflow:
    1. Create a test contact in Google
    2. Create a backup that includes the contact
    3. Delete the contact from Google
    4. Restore from backup
    5. Verify the contact is recreated in Google
    """

    def test_backup_contains_created_contact(
        self, api_account1: PeopleAPI, tmp_path: Path
    ):
        """Test that a created contact appears in the backup."""
        # Create a test contact
        # Note: Google generates display_name from given_name + family_name
        # So we put the test prefix in given_name to make it identifiable
        given_name = get_test_given_name()
        test_contact = Contact(
            resource_name="",  # Will be assigned by Google
            etag="",
            display_name="",  # Will be generated by Google
            given_name=given_name,
            family_name="Backup",
            emails=["backup.test@example.com"],
            phones=["+1-555-0000"],
            notes="This is an E2E test contact for backup verification",
        )

        created_resource = None
        try:
            # Create in Google
            created = api_account1.create_contact(test_contact)
            created_resource = created.resource_name
            assert created_resource, "Contact should have resource_name after create"
            print(f"   Created contact: {created_resource}")

            # Verify contact exists using get_contact (reliable)
            verified = verify_contact_exists(api_account1, created_resource)
            assert verified is not None, "Contact should exist after creation"
            # Google generates display_name from given_name + family_name
            assert given_name in verified.display_name, (
                "Given name should be in display name"
            )

            # Create backup with this single contact
            # Note: We backup the contact we just verified, not from list_contacts()
            backup_dir = tmp_path / "backups"
            bm = BackupManager(backup_dir)

            backup_file = bm.create_backup(
                account1_contacts=[verified],  # Use verified contact directly
                account1_groups=[],
                account2_contacts=[],
                account2_groups=[],
                account1_email="test_account1@example.com",
                account2_email="test_account2@example.com",
            )

            assert backup_file is not None, "Backup should be created"
            assert backup_file.exists(), "Backup file should exist"

            # Load backup and verify contact is there
            backup_data = bm.load_backup(backup_file)
            assert backup_data is not None, "Backup should load"
            assert backup_data["version"] == "2.0", "Backup version should be 2.0"

            acc1_contacts = backup_data["accounts"]["account1"]["contacts"]
            # Contact should have our test prefix in given_name
            test_contacts = [
                c
                for c in acc1_contacts
                if c.get("given_name", "").startswith(TEST_CONTACT_PREFIX)
            ]
            assert len(test_contacts) > 0, "Test contact should be in backup"

            # Verify fields on the test contact
            test_backup = test_contacts[0]
            assert test_backup["emails"] == ["backup.test@example.com"]
            assert test_backup["phones"] == ["+1-555-0000"]
            assert "E2E test contact" in test_backup["notes"]

            print("   SUCCESS: Backup contains created contact with correct fields")

        finally:
            # Cleanup
            if created_resource:
                cleanup_test_contact(api_account1, created_resource)

    def test_full_backup_delete_restore_cycle(
        self, api_account1: PeopleAPI, tmp_path: Path
    ):
        """Test complete cycle: create -> backup -> delete -> restore -> verify."""
        # Create a test contact with unique data
        # Note: Google generates display_name from given_name + family_name
        given_name = get_test_given_name()
        unique_email = f"restore.test.{int(time.time())}@example.com"
        test_contact = Contact(
            resource_name="",
            etag="",
            display_name="",  # Will be generated by Google
            given_name=given_name,
            family_name="Restore",
            emails=[unique_email],
            phones=["+1-555-1234"],
            organizations=["E2E Test Corp"],
            notes="Contact for restore verification",
        )

        original_resource = None
        restored_resource = None
        try:
            # Step 1: Create contact in Google
            print(f"\n1. Creating test contact with given_name: {given_name}")
            created = api_account1.create_contact(test_contact)
            original_resource = created.resource_name
            print(f"   Created: {original_resource}")

            # Step 2: Verify contact exists using get_contact
            print("\n2. Verifying contact exists...")
            verified = verify_contact_exists(api_account1, original_resource)
            assert verified is not None, (
                f"Contact should exist after creation. "
                f"resource_name={original_resource}"
            )
            print("   Verified contact exists")

            # Step 3: Create backup with the verified contact
            print("\n3. Creating backup...")
            backup_dir = tmp_path / "backups"
            bm = BackupManager(backup_dir)

            backup_file = bm.create_backup(
                account1_contacts=[verified],  # Use verified contact
                account1_groups=[],
                account2_contacts=[],
                account2_groups=[],
                account1_email="test@example.com",
                account2_email="test2@example.com",
            )
            print(f"   Backup created: {backup_file}")

            # Step 4: Delete the contact
            print("\n4. Deleting contact from Google...")
            api_account1.delete_contact(original_resource)

            # Step 5: Verify contact is gone
            print("\n5. Verifying contact is deleted...")
            time.sleep(PROPAGATION_WAIT_SECONDS)
            is_deleted = verify_contact_deleted(api_account1, original_resource)
            assert is_deleted, "Contact should be deleted"
            print("   Verified contact is deleted")

            # Step 6: Restore from backup
            print("\n6. Restoring from backup...")
            backup_data = bm.load_backup(backup_file)
            assert backup_data is not None, "Backup should load"
            contacts_to_restore = bm.get_contacts_for_restore(backup_data, "account1")

            # Find our test contact in the backup by given_name
            test_backup_contact = next(
                (c for c in contacts_to_restore if c.given_name == given_name),
                None,
            )
            assert test_backup_contact is not None, "Test contact should be in backup"

            # Restore it
            restored = api_account1.create_contact(test_backup_contact)
            restored_resource = restored.resource_name
            print(f"   Restored: {restored_resource}")

            # Step 7: Verify contact is back using get_contact
            print("\n7. Verifying contact is restored...")
            found = verify_contact_exists(api_account1, restored_resource)
            assert found is not None, (
                f"Contact should exist after restore. resource_name={restored_resource}"
            )
            print("   Verified contact is restored")

            # Verify the data matches
            assert given_name in found.display_name, "Given name should be in display"
            assert unique_email in found.emails, "Email should be preserved"
            assert "+1-555-1234" in found.phones, "Phone should be preserved"

            print("\n8. SUCCESS: Full backup/restore cycle completed!")

        finally:
            # Cleanup - delete both original and restored if they exist
            print("\nCleaning up test contacts...")
            if original_resource:
                cleanup_test_contact(api_account1, original_resource)
            if restored_resource:
                cleanup_test_contact(api_account1, restored_resource)

    def test_restore_preserves_all_fields(
        self, api_account1: PeopleAPI, tmp_path: Path
    ):
        """Test that all contact fields are preserved through backup/restore."""
        # Create contact with many fields populated
        # Note: Google generates display_name from given_name + family_name
        given_name = get_test_given_name()
        test_contact = Contact(
            resource_name="",
            etag="",
            display_name="",  # Will be generated by Google
            given_name=given_name,
            family_name="Fields",
            emails=["field1@example.com", "field2@example.com"],
            phones=["+1-555-1111", "+1-555-2222"],
            organizations=["Org One", "Org Two"],
            notes="Detailed notes\nwith multiple lines\nand special chars: é ñ",
        )

        original_resource = None
        restored_resource = None
        try:
            # Create
            created = api_account1.create_contact(test_contact)
            original_resource = created.resource_name
            print(f"   Created contact: {original_resource}")

            # Verify created contact
            verified = verify_contact_exists(api_account1, original_resource)
            assert verified is not None, "Contact should exist"

            # Backup
            backup_dir = tmp_path / "backups"
            bm = BackupManager(backup_dir)

            backup_file = bm.create_backup(
                account1_contacts=[verified],
                account1_groups=[],
                account2_contacts=[],
                account2_groups=[],
            )

            # Delete
            api_account1.delete_contact(original_resource)
            time.sleep(PROPAGATION_WAIT_SECONDS)

            # Restore
            backup_data = bm.load_backup(backup_file)
            assert backup_data is not None, "Backup should load"
            contacts_to_restore = bm.get_contacts_for_restore(backup_data, "account1")
            test_backup = next(
                c for c in contacts_to_restore if c.given_name == given_name
            )
            restored_contact = api_account1.create_contact(test_backup)
            restored_resource = restored_contact.resource_name
            print(f"   Restored contact: {restored_resource}")

            # Verify all fields using get_contact
            restored = verify_contact_exists(api_account1, restored_resource)
            assert restored is not None, "Restored contact should exist"

            assert given_name in restored.display_name, (
                "Given name should be in display"
            )
            assert restored.given_name == given_name
            assert restored.family_name == "Fields"
            assert set(restored.emails) == {"field1@example.com", "field2@example.com"}
            assert set(restored.phones) == {"+1-555-1111", "+1-555-2222"}
            assert set(restored.organizations) == {"Org One", "Org Two"}
            assert "Detailed notes" in (restored.notes or "")
            assert "special chars: é ñ" in (restored.notes or "")

            print("   SUCCESS: All fields preserved through backup/restore")

        finally:
            if original_resource:
                cleanup_test_contact(api_account1, original_resource)
            if restored_resource:
                cleanup_test_contact(api_account1, restored_resource)


@pytest.mark.integration
class TestBackupRestoreBothAccounts:
    """Test backup/restore across both accounts."""

    def test_backup_both_accounts_separately(
        self,
        api_account1: PeopleAPI,
        api_account2: PeopleAPI,
        tmp_path: Path,
    ):
        """Test that backup correctly separates data from both accounts."""
        # Create unique contacts in each account
        # Note: Google generates display_name from given_name + family_name
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        given_name1 = f"{TEST_CONTACT_PREFIX} Acc1 {ts}"
        given_name2 = f"{TEST_CONTACT_PREFIX} Acc2 {ts}"

        contact1 = Contact(
            resource_name="",
            etag="",
            display_name="",  # Will be generated by Google
            given_name=given_name1,
            family_name="Test",
            emails=["account1.contact@example.com"],
        )
        contact2 = Contact(
            resource_name="",
            etag="",
            display_name="",  # Will be generated by Google
            given_name=given_name2,
            family_name="Test",
            emails=["account2.contact@example.com"],
        )

        resource1 = None
        resource2 = None
        try:
            # Create in respective accounts
            created1 = api_account1.create_contact(contact1)
            created2 = api_account2.create_contact(contact2)
            resource1 = created1.resource_name
            resource2 = created2.resource_name

            # Verify both contacts exist
            verified1 = verify_contact_exists(api_account1, resource1)
            verified2 = verify_contact_exists(api_account2, resource2)
            assert verified1 is not None, "Account1 contact should exist"
            assert verified2 is not None, "Account2 contact should exist"

            # Create backup with both contacts
            backup_dir = tmp_path / "backups"
            bm = BackupManager(backup_dir)

            backup_file = bm.create_backup(
                account1_contacts=[verified1],
                account1_groups=[],
                account2_contacts=[verified2],
                account2_groups=[],
                account1_email="account1@test.com",
                account2_email="account2@test.com",
            )

            # Verify backup structure
            backup_data = bm.load_backup(backup_file)
            assert backup_data is not None, "Backup should load"
            assert backup_data["version"] == "2.0"

            acc1_data = backup_data["accounts"]["account1"]
            acc2_data = backup_data["accounts"]["account2"]

            assert acc1_data["email"] == "account1@test.com"
            assert acc2_data["email"] == "account2@test.com"

            # Verify contacts are in correct accounts by given_name
            acc1_given = [c.get("given_name", "") for c in acc1_data["contacts"]]
            acc2_given = [c.get("given_name", "") for c in acc2_data["contacts"]]

            assert given_name1 in acc1_given, "Account1 contact should be in account1"
            assert given_name2 in acc2_given, "Account2 contact should be in account2"

            # Verify contacts are NOT in wrong accounts
            assert given_name2 not in acc1_given, "Acc2 contact should NOT be in acc1"
            assert given_name1 not in acc2_given, "Acc1 contact should NOT be in acc2"

            print("   SUCCESS: Both accounts backed up separately")

        finally:
            if resource1:
                cleanup_test_contact(api_account1, resource1)
            if resource2:
                cleanup_test_contact(api_account2, resource2)
